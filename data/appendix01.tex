%!TEX root = ../main.tex

\chapter{超导量子比特的原理} % (fold)
\label{cha:SCQubitPrinciple}
  
% chapter SCQubitPrinciple (end)


\chapter{微纳加工工艺} % (fold)
\label{cha:fabrication}

\section{光刻} % (fold)
\label{sec:光刻}
    \begin{enumerate}
        \item Spin coating S1805, 500 nm
        \item Bake at 115 degree C for 1 min
        \item Align mask
        \item Expose with 405 nm UV light for 9.5s
        \item Develop with MF-319 for 45s， power 350W
        \item Clean in DI-water and blow dry
    \end{enumerate}
% section 光刻 (end)

\section{介电层生长} % (fold)
\label{sec:介电层生长}
    \begin{enumerate}
        \item PECVD生长SiO$_2$速率：
        \item PECVD生长SiN$_x$速率：
        \item ALD生长Al$_2$O$_3$速率：
    \end{enumerate}
% section 介电层生长 (end)

\section{磁控溅射镀膜} % (fold)
\label{sec:磁控溅射镀膜}
    
% section 磁控溅射镀膜 (end)

\section{Argon milling去除氧化层} % (fold)
\label{sec:argon_milling去除氧化层}

% section argon_milling去除氧化层 (end)

\section{点焊} % (fold)
\label{sec:点焊}
    \begin{enumerate}
        \item 一焊由于PCB上的SMP接头的空间位置原因需位于器件上，焊接使用铝线
        \item 一焊参数：功率220，时间30ms，力19
        \item 二焊参数：功率330，时间40ms，力19
        \item 点焊时应使焊线尽可能地短而密
    \end{enumerate}
% section 点焊 (end)
  
% chapter fabrication (end)

\chapter{PPMS系统的常用操作} % (fold)
\label{cha:ppms系统的常用操作}
    对于PPMS的详细介绍可参阅PPMS的用户手册，本附录在读者熟悉PPMS相关术语与参数（如Chamber Pressure等）的前提下，为使用者提供一个方便参考的操作流程。
    在正常的测量状态下，Chamber Pressure与样品室温度有关，样品温度为2K左右时一般为300至400mTorr，chamber state应该为Purged，意为样品室已用He气清洗并抽真空。在非远程控制PPMS时，一般通过与PPMS相连的电脑上的MultiVu程序控制PPMS。该程序主面板下方有若干小面板，点击这些小面板可调出设定温度，磁场与样品室状态的分面板。常用的分面板也即前文提到的Temperature，Chamber，Field面板。

    \section{调节温度与磁场} % (fold)
    \label{sec:调节温度}
        在Temperature面板中，status显示当前样品温度。通过Control一栏即可设置目标温度（set point）以及调温的速率（Rate）。Mode选项有Fast settle和No overshoot两种，也即快速和非振荡的平稳到达目标温度两种模式。

        升温时最大速率不应超过20K/min，降温时最大速率不应超过10K/min。


        调节磁场与调节温度十分类似。
    % section 调节温度 (end)

    \section{更换样品} % (fold)
    \label{sec:更换样品}
        首先升温至室温，300K，从2K开始升温则需约30分钟。样品室升至常温后，样品室气压约为20~40Torr。点击Chamber分面板的Vent/Seal，此时样品室气压将快速升至常压，约790Torr，此后即可取出样品杆。若取出样品杆时间较长，应插入空样品杆并点击Chamber分面板的Purge/Seal以使样品室处于较好的密封环境。

        更换完样品并插入封好样品杆后，点击Chamber分面板的Purge/Seal，此时state变为Purging。样品室气压将在常压与~30Torr间来回反复若干次，约5分钟后state变为Purged，此时即可开始制冷。
    % section 更换样品 (end)
% chapter ppms系统的常用操作流程 (end)

\chapter{测量系统MATLAB代码} % (fold)
\label{cha:measurement_code}

通过MATLAB控制仪器，能够十分方便地调整仪器的各项参数以及从仪器采集所需数据。对于封装较好的代码，能够可扩展地编写与控制更为复杂的实验。因此我通过MATLAB实现了对VNA的控制与数据采集，基于PPMS仪器商提供的动态链接库文件实现了对PPMS系统的状态读取与控制。在这二者的基础上，编写了扫描不同温度与磁场下的频率响应的实验的代码。

本附录中将给出VNA与PPMS的MATLAB控制程序代码，以及扫描温度与磁场的MATLAB代码。


  \section{VNA控制代码} % (fold)
  \label{sec:vna控制代码}

  \begin{lstlisting}
classdef E5071C < handle
    % E5071C describe and control the agilent E5071C ENA
    %
    % EXAMPLES (assume instance named 'vna'):
    %   initialization:
    %       vna = E5071C;
    %       vna = E5071C('address',8,'InputBufferSize',100000);
    %   set & get parameters
    %       % fetch & return the start frequency:
    %       freq = vna.freqStart;
    %       % fetch & return the IFBW:
    %       bw = vna.ifbw;
    %       % set the stop frequency to 5GHz:
    %       vna.freqStop = 5e9;
    %       % set the number of average and turn on averaging:
    %       vna.avg = 999;
    %   fetch trace:
    %       % fetch the trace data, return a structure
    %       trace = vna.trace
    %
    %   See E5071C/plotTrace, E5071C/fit and E5071C/manualSweep for detail usage
    %
    %   Wentao, April 2017
    %
    
    properties (Constant)
        MAX_POINTS = 1601;
        MAX_AVG = 999;
        
    end

    properties
        visa
        InputBufferSize
        TimeOut
        
        address
        
        % properties with set & get methods
        freqStart
        freqStop
        freqSpan
        freqCenter        
        avg
        numOfPoints
        ifbw
        meas        
        outp
        power
        trigMode
        
        trace
        
        freqs
        h_fig       % figure handle
    end
    
    methods
        
        function obj = E5071C(varargin)
            % Initialize E5071C object
            %
            p = inputParser;
            p.addParameter('address',6, @isnumeric);        % GPIB address
            p.addParameter('InputBufferSize',30000, @isnumeric);
            p.addParameter('TimeOut',20, @isnumeric);
            p.parse(varargin{:});
            expandStructure(p.Results);
            
            obj.address = address;
            obj.TimeOut = TimeOut;
            obj.InputBufferSize = InputBufferSize;
            
            obj.visa = visa('agilent',sprintf('GPIB::%d::INSTR',obj.address));
            fprintf('%s\nConnected.\n',obj.read('*IDN?','%s'));
            set(obj.visa,'InputBufferSize', obj.InputBufferSize);
            set(obj.visa,'TimeOut', obj.TimeOut);
            % Set byte order to swapped (little-endian) format  
            fprintf('Set byte order to little-endian...');
            obj.write(':FORMAT:BORD SWAP');
            fprintf('Done.\n')
            % Set data type to real 64 bit binary block 
            fprintf('Set data type to real 64 bit binary block...');
            obj.write(':FORMAT:DATA REAL');
            fprintf('Done.\n');
        end
        
        function delete(obj)
            delete(obj.visa);
        end
        
        %% frequency set & get
        function value = get.freqStart(obj)
            value = obj.read(':sens:freq:star?', '%f');
        end
        function set.freqStart(obj,val)
            obj.write(':sens:freq:star %f',val);
        end
        function value = get.freqStop(obj)
            value = obj.read(':sens:freq:stop?', '%f');
        end
        function set.freqStop(obj,val)
            obj.write(':sens:freq:stop %f',val);
        end
        function value = get.freqCenter(obj)
            value = obj.read(':sens:freq:cent?', '%f');
        end
        function set.freqCenter(obj,val)
            obj.write(':sens:freq:cent %f',val);
        end
        function value = get.freqSpan(obj)
            value = obj.read(':sens:freq:span?','%f');
        end
        function set.freqSpan(obj,val)
            obj.write(':sens:freq:span %f', val);
        end
        
        %% sweep setup: measurement parameter, points, average, ifbw
        function value = get.meas(obj)
            value = obj.read(':CALC:PAR:DEF?', '%s');
        end
        function set.meas(obj, val)
            obj.write(':CALC:PAR:DEF %s', val);
        end
        function value = get.numOfPoints(obj)
            value = obj.read(':sens:swe:poin?', '%f');
        end
        function set.numOfPoints(obj, val)
            obj.write( ':sens:swe:poin %d', val);
        end
        
        function value = get.avg(obj)
            value = obj.read( ':sens:aver:count?', '%f');
        end
        function set.avg(obj, val)
            obj.write( ':sens:aver:count %d', val);
            obj.write(':SENSe:AVERage:STATe 1');
        end        
        function clearAvg(obj)
            obj.write(':SENSe:AVERage:CLE');
        end
        
        function value = get.ifbw(obj)
            value = obj.read(':sens:BWID:RES?', '%f');
        end
        function set.ifbw(obj, val)
            obj.write( ':sens:BWID:RES %f', val);
        end
        
        function val = sweepTime(obj)
            val = obj.read('SENS:SWE:TIME:DATA?','%f');
        end
        
        
        %% output & trigger
        function value = get.power(obj)
            value = obj.read(':SOURce:POWer:LEVel:IMMediate:AMPLitude?', '%f');
        end
        function set.power(obj, val)
            obj.write(':SOURce:POWer:LEVel:IMMediate:AMPLitude %d', val);
        end
        function value = get.outp(obj)
            value = obj.read(':OUTP:STATe?', '%f');
        end
        function set.outp(obj, val)
            obj.write(':OUTP:STATe %d', val);
        end
        function value = get.trigMode(obj)
            value = obj.read(':TRIG:SEQ:SOUR?','%s');
        end
        function set.trigMode(obj, val)
            % set.trigMode sets trigger mode
            %   available options: 'INT', 'EXT', 'MAN', 'BUS'
            %     Internal Trigger
            %     Uses the internal trigger to generate continuous triggers automatically.
            % 
            %     External Trigger
            %     Generates a trigger when the trigger signal is inputted externally via the Ext Trig connector or the handler interface.
            % 
            %     Manual Trigger
            %     Generates a trigger when the key operation of Trigger > Trigger is executed from the front panel.
            % 
            %     Bus Trigger
            %     Generates a trigger when the SCPI.IEEE4882.TRG object is executed.

            obj.write(':TRIG:SEQ:SOUR %s',val);
        end
        
        %% set & get configurations
        function setConfig(obj, config)
            % setConfig apply parameters to E5071C
            % config should have same or less fields as E5071C properties
            % with set & get methods
            flds = fieldnames(config);
            for ii = 1:length(flds)
                fld = flds{ii};
                obj.(fld) = config.(fld);
            end
        end
        
        function params = getConfig(obj)
            % getConfig returns E5071C object parameters for saving
            % configuration
            flds = {'freqStart',...
                'freqStop',...
                'freqSpan',...
                'freqCenter',...
                'avg',...
                'numOfPoints',...
                'ifbw',...
                'meas',...
                'outp',...
                'power',...
                'trigMode'};            
            for ii = 1:length(flds)
                fld = flds{ii};
                params.(fld) = obj.(fld);
            end
        end
        
        
        %% get & plot trace
        function autoScale(obj)
            % autoScale auto-scales the y axis
            % for viewing the image via web server
            obj.write(':DISP:WIND:TRAC:Y:SCAL:AUTO');
        end
        function value = get.freqs(obj)            
            value = obj.freqStart:((obj.freqStop...
                - obj.freqStart)/obj.numOfPoints):obj.freqStop;
            value = value(1:end-1);
        end
        function value = get.trace(obj)
            % adopted from https://community.keysight.com/thread/22342
            fopen(obj.visa);
            fprintf(obj.visa, 'CALC:DATA:SDAT?'); 
            [data, count, msg] = binblockread(obj.visa, 'double'); 
            fclose(obj.visa);
            value.count = count;
            value.msg = msg;
            value.X = data(1:2:end); 
            value.Y = data(2:2:end);
        end
        
        function titleStr = plotTrace(obj, varargin)
            % plotTrace fetch & plot trace data
            % EXAMPLE (assume the object is named 'vna'):
            %   vna.plotTrace;
            %   vna.plotTrace('issavefig', true);
            %   vna.plotTrace('issavefig', true,'filename','test');
            %
            % See the inputParser below for more options
            %   
            
            p = inputParser;
            p.addParameter('issavedata',false,@islogical);
            p.addParameter('issavefig',false,@islogical);
            p.addParameter('avg',1,@isnumeric);
            p.addParameter('filename','',@ischar);
            p.addParameter('format','png',@ischar);
            p.parse(varargin{:});
            expandStructure(p.Results);
            
            if avg > 1
                pause(round(avg*obj.sweepTime + 1));
            end
            
            hfig = figure;
            obj.h_fig = hfig;
            trace = obj.trace;
            
            plot(obj.freqs/1e9,...
                20*log10(abs(trace.X + 1i*trace.Y)));
            xlabel freq/GHz
            ylabel SParameter/dB
            titleStr = ['start_' num2str(obj.freqStart/1e9)...
                'GHz_stop_'  num2str(obj.freqStop/1e9)...
                'GHz_pow_' num2str(obj.power)...
                'dBm_AVG_' num2str(avg)];
            title(titleStr, 'interpreter','none');
            
            if issavefig
                if ~isempty(filename)
                    titleStr = filename;
                end
                saveas(hfig, [titleStr format]);
            end
            
            if issavedata  
                str = titleStr;
                freqs = obj.freqs;
                config = obj.getConfig;
                save([str '.mat'],'freqs','trace','str','config');
            end      
            
        end
        
        function [freqs, trace] = manualSweep(obj, varargin)
            % manualSweep defines and does a manual frequency sweep
            % main purpose is for wide sweep with high resolution for
            % finding modes
            %
            % EXAMPLE:
            %   [freqs, trace] = vna.manualSweep('start',1e9,'stop',9e9,'res',1e5);
            %   [freqs, trace] = vna.manualSweep('start',3.5e9,'stop',3.6e9,'res',1e4, 'avg',999);
            %   [freqs, trace] = vna.manualSweep('center',4.9655e9,'span',1e6,'res',0.001e6,'avg',2,'ifbw',100,'pow',-10);
            %
            %
            % See the inputParser below for more options
            %
            
            p = inputParser;
            p.addParameter('start',1e9,@isnumeric); % start frequency
            p.addParameter('stop',8e9,@isnumeric);  % stop frequency
            p.addParameter('res',1e6,@isnumeric);   % frequency resolution
            p.addParameter('avg', 1, @isnumeric);       % number of average
            p.addParameter('ifbw', 100, @isnumeric);    % ifbw of vna
            p.addParameter('points', obj.MAX_POINTS, @isnumeric); % number of points of vna
            p.addParameter('pow', -100, @isnumeric); % power of vna, default below
                                                        % the lowest power of E5071C,
                                                        % hence this
                                                        % parameter only
                                                        % takes effect if it
                                                        % is given a valid
                                                        % value
            p.addParameter('center', 0, @isnumeric);  % frequency sweep can also be defined
                                                      % by center and span,
                                                      % if they are given a
                                                      % valid value
            p.addParameter('span',0, @isnumeric);
            p.addParameter('issavedata',true,@islogical);
            p.addParameter('hfig',233,@isnumeric);      % figure handle
            p.addParameter('notes','',@ischar);         % notes to add in file name
            
            p.parse(varargin{:});
            expandStructure(p.Results);
            
            freqSectionSpan = res * points;
            freqSectionSpan = 1e6 * round(freqSectionSpan/1e6);
            if span ~= 0 && center ~= 0
                start = center - span/2;
                stop = center + span/2;
            end
            numOfSections = ceil((stop - start)/freqSectionSpan);
            stop = start + numOfSections * freqSectionSpan;
            totalPoints = points * numOfSections;
            
            % initialize
            freqs = NaN(1, totalPoints);
            trace.X = freqs;
            trace.Y = freqs;
            
            % apply parameters
            obj.ifbw = ifbw;
            if pow > -85
                obj.power = pow;
            end
            obj.numOfPoints = points;
            obj.freqSpan = freqSectionSpan;
            obj.avg = obj.MAX_AVG;
            
            sweepTime = obj.sweepTime;
            waitTime = ceil(avg * sweepTime) + 1;
            
            figure(hfig);
            xlabel freq/GHz
            ylabel SParameter/dB
            str = sprintf('start_%.2fGHz_stop_%.2fGHz_res_%.2fMHz_pow_%ddBm_AVG_%d',...
                start/1e9,stop/1e9,res/1e6,obj.power,avg);
            title(str,'interpreter','none');
            
            fprintf('\tsweep from %.2fGHz to %.2fGHz, %d sections, %ds per section\n\ttotal points: %d, total time: %ds.\n',...
                start/1e9,stop/1e9, numOfSections,waitTime,totalPoints, waitTime * numOfSections);
            for i = 1:numOfSections
                obj.freqCenter = start + freqSectionSpan/2 +  freqSectionSpan* (i-1);
                fprintf('sweeping %.2fGHz to %.2fGHz...\n',obj.freqStart/1e9,obj.freqStop/1e9);
                pause(waitTime);
                tmptrace = obj.trace;
                tmpfreqs = obj.freqs;
                freqs((1 + (i-1)*points):(i*points)) = tmpfreqs;
                trace.X((1 + (i-1)*points):(i*points)) = tmptrace.X';
                trace.Y((1 + (i-1)*points):(i*points)) = tmptrace.Y';
                figure(hfig);
                plot(freqs/1e9, 20*log10(abs(trace.X + 1i*trace.Y)));
            end
            fprintf('Sweep finished!\n');
            
            figure(hfig);
            xlabel freq/GHz
            ylabel SParameter/dB
            str = sprintf('start_%.2fGHz_stop_%.2fGHz_res_%.2fMHz_pow_%ddBm_AVG_%d%s',...
                start/1e9,stop/1e9,res/1e6,pow,avg,notes);
            title(str,'interpreter','none');
            
            if issavedata
                config = obj.getConfig;
                save([str '.mat'],'freqs','trace','str','config');
            end      
            obj.h_fig = hfig;
            
        end
        
        
        
        function [freqs,totalWaitTime] = manualSweepFreqs(obj, varargin)
            % manualSweepFreqs quickly calculate frequencies of
            % manualSweep, does not do the sweep
            %
            % ATTENTION: this method will modify the vna sweep frequency!
            %
            % See the inputParser below for more options
            %
            
            p = inputParser;
            p.addParameter('start',1e9,@isnumeric); % start frequency
            p.addParameter('stop',8e9,@isnumeric);  % stop frequency
            p.addParameter('res',1e6,@isnumeric);   % frequency resolution
            p.addParameter('avg', 1, @isnumeric);       % number of average
            p.addParameter('ifbw', 100, @isnumeric);    % ifbw of vna
            p.addParameter('points', obj.MAX_POINTS, @isnumeric); % number of points of vna
            p.addParameter('pow', -100, @isnumeric); % power of vna, default below
                                                        % the lowest power of E5071C,
                                                        % hence this
                                                        % parameter only
                                                        % takes effect if it
                                                        % is given a valid
                                                        % value
            p.addParameter('center', 0, @isnumeric);  % frequency sweep can also be defined
                                                      % by center and span,
                                                      % if they are given a
                                                      % valid value
            p.addParameter('span',0, @isnumeric);
            
            % useless, but required for input parser to be identical with input parser for manualSweep; 
            p.addParameter('issavedata',true,@islogical);
            p.addParameter('hfig',233,@isnumeric);      % figure handle
            p.addParameter('notes','',@ischar);         % notes to add in file name
            
            
            p.parse(varargin{:});
            expandStructure(p.Results);
            
            freqSectionSpan = res * points;
            freqSectionSpan = 1e6 * round(freqSectionSpan/1e6);
            if span ~= 0 && center ~= 0
                start = center - span/2;
                stop = center + span/2;
            end
            numOfSections = ceil((stop - start)/freqSectionSpan);
            stop = start + numOfSections * freqSectionSpan;
            totalPoints = points * numOfSections;
            
            % initialize
            freqs = NaN(1, totalPoints);
            
            % apply parameters
            obj.ifbw = ifbw;
            if pow > -85
                obj.power = pow;
            end
            obj.numOfPoints = points;
            obj.freqSpan = freqSectionSpan;
            obj.avg = obj.MAX_AVG;
            
            sweepTime = obj.sweepTime;
            waitTime = ceil(avg * sweepTime) + 1;
            totalWaitTime = waitTime * numOfSections;
            
            for i = 1:numOfSections
                obj.freqCenter = start + freqSectionSpan/2 +  freqSectionSpan* (i-1);

                tmpfreqs = obj.freqs;
                freqs((1 + (i-1)*points):(i*points)) = tmpfreqs;
            end
            
        end
      
        %% fit
        function  [ f_r,Q_i,Q_c,Q_l ] = fit(obj,varargin)
            % select range and fit plot
            % ATTENTION: use vna.plotTrace or vna.manualSweep first and then use vna.fit!
            % EXAMPLE:
            %   vna.plotTrace;
            %   vna.fit('fitall',true);
            % you can also give data to this method:            
            %     [ f_r,Q_i,Q_c,Q_l ] = vna.fit('fitall',true,'issavefig',false,...
            %                                   'xdata',freqs,'ydata',20*log10(abs(SParams)),...
            %                                   'titleNotes','_pow_-10dBm' );
            %
            % See the inputParser below for more options
            %
            
            p = inputParser;
            p.addParameter('issavefig',true,@islogical);% if true, save fig to png file
            p.addParameter('fitall', false,@islogical); % if true, fit all
                                                        % plotted data,
                                                        % else ask two
                                                        % input for the fit
                                                        % range
            p.addParameter('xdata',[],@isnumeric);      % xdata in GHz frequency
            p.addParameter('ydata',[],@isnumeric);      % ydata given in dB
            p.addParameter('titleNotes','',@ischar);    % notes to add to the figure title
            p.addParameter('QGuess',1e5,@isnumeric);
            p.parse(varargin{:});
            expandStructure(p.Results);
            
            dataObj = get(gca,'children');
            if isempty(xdata)
                xdata = get(dataObj,'xdata');
            end
            if isempty(ydata)
                ydata = get(dataObj,'ydata');
            end
            
            if gcf == obj.h_fig
                figure(obj.h_fig);
            else
                figure(obj.h_fig);
                plot(xdata, ydata);
                % assume GHz frequency
                xlabel frequency/GHz;
                ylabel S/dB;
                title([sprintf('start_%.4fGHz_stop_%.4fGHz',...
                    min(xdata)/1e9, max(xdata)/1e9 ) titleNotes],'interpreter','none');
            end
                
            if fitall
                leftInd = 1;
                rightInd = length(xdata);
            else
                fprintf('Select the X range for fitting:');
                tmpPoints = ginput(2);
                leftX = min(tmpPoints(:,1));
                rightX = max(tmpPoints(:,1));
                leftInd = find(leftX < xdata, 1);
                rightInd = find(rightX < xdata, 1);
            end
            t = xdata(:);
            y = ydata(:);
            % assume xdata given in GHz
            t = t(leftInd:rightInd)*1e9;
            % assume ydata given in dB, convert to linear
            y = 10.^(y(leftInd:rightInd)./20);

            % guess initial parameters
            peakInd = find(abs(ydata)>=max(abs(ydata)),1);
            freq0 = xdata(peakInd); % in GHz
            x1 = [freq0, QGuess/1e4, QGuess/1e4, 0, 0, 0];

            % fit with complex S21 deduced theoretically
            % 8 parameter, linear base
            %         F = @(x,xdata)(20.*log10(abs(x(6).*(1+x(5).*(xdata-x(1).*1e9)./(x(1).*1e9)).*(1-(x(2).^2.*1e4.*x(3).^2.*1e4./cos(x(4)))./(x(2).^2.*1e4 + x(3).^2.*1e4./cos(x(4)))./(x(3).^2.*1e4).*(cos(x(4))+1i.*sin(x(4)))./(1+2.*1i.*(x(2).^2.*1e4.*x(3).^2.*1e4./cos(x(4)))./(x(2).^2.*1e4 + x(3).^2.*1e4./cos(x(4))).*(xdata-x(1).*1e9)./(x(1).*1e9)))))+x(7).*xdata.*1e-9+x(8));
            % 7 parameter, constant base
            F = @(x,xdata)(abs(x(6).*(1+x(5).*(xdata-x(1).*1e9)./(x(1).*1e9)).*(1-(x(2).^2.*1e4.*x(3).^2.*1e4./cos(x(4)))./(x(2).^2.*1e4 + x(3).^2.*1e4./cos(x(4)))./(x(3).^2.*1e4).*(cos(x(4))+1i.*sin(x(4)))./(1+2.*1i.*(x(2).^2.*1e4.*x(3).^2.*1e4./cos(x(4)))./(x(2).^2.*1e4 + x(3).^2.*1e4./cos(x(4))).*(xdata-x(1).*1e9)./(x(1).*1e9)))));
            %x(1): f, center frequency, in GHz
            %x(2): Qi, intrinsic Q, Ql = Qi*Qc/(Qi + Qc) =  (x(2).*x(3)./cos(x(4)))./(x(2) + x(3)./cos(x(4))), in 1e4
            %x(3): |Qe|, parameter Q, 1/Qc = Re (1/Qe) = cos(theta)/Qe, in 1e4
            %x(4): theta, phase of parameter Q
            %x(5): alpha
            %x(6): amplitude A

    
            opt=optimset('MaxIter',10000,'MaxFunEvals',10000,'tolx',1e-16,'tolf',1e-9);
            for loop_fit=1:5            
                [x_fit1,resnorm,~,exitflag,output] = lsqcurvefit(F,x1,t,y,[],[],opt);
                x1=x_fit1;
                if ((x1(4)>pi/2)||(x1(4)<-pi/2))
                    tmp = floor(abs(x1(4))./(pi/2));
                    if x1(4)>0
                        x1(4)=x1(4)-tmp.*pi/2;
                    end
                    if x1(4)<0
                        x1(4)=x1(4)+tmp.*pi/2;
                    end
                end
            end
            
            f_r = x1(1)*1e9; % center frequency, in Hz
            Q_i = x1(2).^2.*1e4; % interal Q
            Q_c = x1(3).^2./cos(x1(4)).*1e4;  % coupled Q
            Q_l = Q_i.*Q_c./(Q_i + Q_c);  % loaded Q
            
            figure(obj.h_fig);
            hold on
            plot(t/1E9,20*log10(y),'.',t/1E9,20*log10(F(x_fit1,t)),'LineWidth',2);
            f_text=['f_r = '];
            f_text=[f_text num2str(f_r/1e9)];
            f_text=[f_text 'GHz'];
            Ql_text=['Q_l = ' num2str(round(Q_l))];
            Qi_text=['Q_i = ' num2str(round(Q_i))];
            Qc_text=['Q_c = ' num2str(round(Q_c))];
            text_pos=[(max(20*log10(y))-min(20*log10(y)))/4+min(20*log10(y)),min(20*log10(y))];
            text(t(1)/1E9,text_pos(1),f_text,'FontSize',18);
            text(t(1)/1E9,text_pos(2),Ql_text,'FontSize',18);
            text(t(round(end/1.5))/1E9,text_pos(1),Qi_text,'FontSize',18);
            text(t(round(end/1.5))/1E9,text_pos(2),Qc_text,'FontSize',18);
            hold off
            
            if issavefig
                str = ['Fit_' get(get(gca,'Title'),'String') '.png'];
                saveas(obj.h_fig,str);   
                fprintf(['Image ' str ' saved.\n'])
            end

        end
        
        
    end
    
        
    
    %% private methods
    methods (Access = private)
        function val = read(obj, varargin)
            % varargin{1:(end-1)} are commands to be sent as a formatted
            % string
            % varargin{end} is the read format
            fopen(obj.visa);
            fprintf(obj.visa, varargin{1:(end-1)});
            val = fscanf(obj.visa, varargin{end});
            fclose(obj.visa);
        end
        function write(obj, varargin)
            fopen(obj.visa);
            fprintf(obj.visa, varargin{:});
            fclose(obj.visa);
        end
    end
end
  \end{lstlisting}
    
  % section vna控制代码 (end)

  \section{PPMS控制代码} % (fold)
  \label{sec:ppms控制代码}
  \begin{lstlisting}
classdef PPMS < handle
    % PPMS describe and control QDInstrument DynaCool at IIIS via QDInstrument.dll,
    % which is much faster than using dll created from LabVIEW.
    %
    % Calling dll created from LabVIEW is slow and generates new client
    % at each function call, which is very bad and troublesome. This
    % version of PPMS avoided the above two problems.
    %
    % EXAMPLES (assuming instance named 'ppms'):
    %
    % Initialization:
    %   ppms = PPMS;
    %   ppms = PPMS('address','101.6.98.151','isremote',true,'dllfilepath','C:\Users\IIIS\Documents\MATLAB\PPMS\QDInstrument.dll');
    % Get temperature value and status:
    %   temp = ppms.temp;
    %   stat = ppms.tempStatus;     % This returns a .NET object, use
    %                               % char(stat.ToString) to get the
    %                               % string, or directly use char(ToString(ppms.fieldStatus))
    %   statStr = ppms.tempStatusStr;   % Directly get the temperature
    %                                   % status string
    % Get field value and status:
    %   fld = ppms.field;
    %   stat = ppms.fieldStatus;    % See notes for ppms.tempStatus above
    %   statStr = ppms.fieldStatusStr;  % Directly get the field
    %                                   % status string
    %
    % Set temperature:
    %   ppms.setTemp(4);
    %   ppms.setTemp(2,'tempRate',5,'tempApproach','NoOvershoot');
    %   ppms.setTemp(300,'tempRate',20,'tempApproach','FastSettle');
    %
    % Set field, field strength in Gauss (Oe):
    %   ppms.setField(0,'fieldRate',50,'fieldApproach','Linear');
    %   ppms.setField(200,'fieldRate',100);
    %   ppms.setField(500,'fieldMode','Persistent');
    % 
    % See Constant properties for available options for 'tempApproach',
    % 'fieldApproach', and 'fieldMode'
    %
    % ATTENTION: 
    %   1. Setting 'fieldMode' to 'Persistent' etc. is not working as
    %       expected.
    %   2. Sometimes you might need to manually load the dll file using NET.addAssembly(dllfilepath)
    %       when you first started MATLAB, try initializing ppms and also try
    %       calling QuantumDesign.QDInstrument.QDInstrumentType.DynaCool
    %       etc. for multiple times until it works. It will work when
    %       auto-completion (by using TAB button) works.
    %
    % In development (May 12, 2017)
    % Testing (May 13, 2017)
    % Add get status in string format (May 14, 2017)
    % Wentao, May 2017
    %

properties (Constant)
    % the second argument (numeric arrays) of these Constants is of no use
    % the containers.Map is used for utilizing the isKey method, see
    % the prirvate methods for parameter verification.
    INSTR_TYPE = containers.Map({'PPMS','VersaLab','DynaCool','SVSM'},[0,1,2,3]);
    
    TEMP_APPROACH = containers.Map({'FastSettle','NoOvershoot'},[0,1]);
    
    FIELD_APPROACH = containers.Map({'Linear','NoOvershoot','Oscillate'},...
                        [0,1,2]);
    FIELD_MODE = containers.Map({'Persistent','Driven'},[0,1]);
    
end

properties
    dllfilepath
    address
    isremote
    instrType
    
    QDInstr
    vi
    
    temp
    field
    tempStatus
    fieldStatus
    
    tempApproach
    tempRate
    fieldMode
    fieldRate
    fieldApproach
end

methods
    function obj = PPMS(varargin)
        % initialize PPMS
        p = inputParser;
        p.addParameter('address','101.6.98.151',@ischar);       % ip address of PPMS computer
        p.addParameter('dllfilepath','C:\Users\IIIS\Documents\MATLAB\PPMS\QDInstrument.dll',@ischar);
        p.addParameter('isremote',true,@islogical);             % is remote (is MATLAB and MultiVu on different computer)
        p.addParameter('instrType','DynaCool',@checkInstrType); % instrument type
        
        p.parse(varargin{:})
        expandStructure(p.Results);
        
        
        obj.address = address;
        obj.dllfilepath = dllfilepath;
        obj.isremote = isremote;
        obj.instrType = instrType;
        obj.tempApproach = 'Unknown';
        obj.fieldMode = 'Unknown';
        obj.fieldApproach = 'Unknown';
        obj.tempRate = NaN;
        obj.fieldRate = NaN;
        
        obj.QDInstr = NET.addAssembly(dllfilepath);
        pause(1);
        obj.tempStatus = QuantumDesign.QDInstrument.TemperatureStatus.TemperatureUnknown;
        obj.fieldStatus = QuantumDesign.QDInstrument.FieldStatus.MagnetUnknown;
        
        % initialize .NET object which is the vi for the ppms
        obj.vi = QuantumDesign.QDInstrument.QDInstrumentFactory.GetQDInstrument(...
                            QuantumDesign.QDInstrument.QDInstrumentType.(instrType),...
                            isremote,address,uint16(11000) );
        fprintf('PPMS %s at %s connected.\n',obj.instrType, obj.address);
        
        
    end
    
    %% set & get temperature
    function value = get.temp(obj)
        [~, value, obj.tempStatus] = GetTemperature(obj.vi, double(0), obj.tempStatus);
    end
    function value = get.tempStatus(obj)
        [~, obj.temp, value] = GetTemperature(obj.vi, double(0), obj.tempStatus);
    end
    function str = tempStatusStr(obj)
        str = char(ToString(obj.tempStatus));
    end
    
    function setTemp(obj,varargin)
        p = inputParser;
        p.addRequired('temperature');
        p.addParameter('tempRate',10,@isnumeric);
        p.addParameter('tempApproach','FastSettle',@obj.checkTempApproach);
        p.parse(varargin{:});
        expandStructure(p.Results);
        
        obj.tempApproach = tempApproach;
        obj.tempRate = tempRate;
        
        SetTemperature(obj.vi, double(temperature),double(tempRate),...
                        QuantumDesign.QDInstrument.TemperatureApproach.(tempApproach));     
        
        
    end
    
    
    %% set & get field
    function value = get.field(obj)
        [~, value, obj.fieldStatus] = GetField(obj.vi, 0, obj.fieldStatus);
    end
    function value = get.fieldStatus(obj)
        [~, obj.field, value] = GetField(obj.vi, 0, obj.fieldStatus);
    end
    function str = fieldStatusStr(obj)
        str = char(ToString(obj.fieldStatus));
    end
    
    function setField(obj,varargin)
        p = inputParser;
        p.addRequired('b_field');
        p.addParameter('fieldRate',100,@isnumeric);
        p.addParameter('fieldMode','Driven',@obj.checkFieldMode)
        p.addParameter('fieldApproach','Linear',@obj.checkFieldApproach);
        p.parse(varargin{:});
        expandStructure(p.Results);
        
        obj.fieldMode = fieldMode;
        obj.fieldRate = fieldRate;
        obj.fieldApproach = fieldApproach;
        
        SetField(obj.vi, double(b_field),double(fieldRate),...
                        QuantumDesign.QDInstrument.FieldApproach.(fieldApproach),...
                        QuantumDesign.QDInstrument.FieldMode.(fieldMode));         
        
    end
    
    %% TODO: add set & get chamber (not so necessary since we have remote desktop)
    
    %% quick methods
    function warmup(obj)
        obj.setField(0);
        obj.setTemp(300,'tempRate',20);
    end
    
    
end

methods(Access = private)
    % methods for checking string input validity
    function passed = checkInstrType(obj, instrType)
        passed = isKey(obj.INSTR_TYPE, instrType);
    end

    function passed = checkTempApproach(obj, tempMode)
        passed = isKey(obj.TEMP_APPROACH,tempMode);
    end
    
    function passed = checkFieldMode(obj, fieldMode)
        passed = isKey(obj.FIELD_MODE,fieldMode);
    end
    function passed = checkFieldApproach(obj, fieldApproach)
        passed = isKey(obj.FIELD_APPROACH,fieldApproach);
    end
end
end
  \end{lstlisting}
    
  % section ppms控制代码 (end)

  \section{扫描温度与磁场实验的代码} % (fold)
  \label{sec:扫描温度与磁场实验的代码}
  \subsection{扫描温度} % (fold)
  \label{sub:扫描温度}
\begin{lstlisting}
%%
function [tempStableTmr, setTempTmr] = TempSweep(ppms,vna,temps,varargin)
% temperature sweep
%
% Parameters:
%   ppms: the PPMS object
%   vna: the E5071C object
%   temps: temperatures to sweep
%   varargin: optional input arguments, see inputParser below for detail
%
% Returns:
%   Two timer object tempStableTmr and setTempTmr.
% 
%   Sweep results will be automatically saved.
%   You can also find parameters and sweep results in
%   tempStableTmr.UserData and setTempTmr.UserData
%   It's better to delete and clear the timer object since they'll remained
%   in the memory:
%         delete(tempStableTmr);
%         delete(setTempTmr);
%         clear setTempTmr;
%         clear tempStableTmr;
%
% ATTENTION: the waiting process (for the temperature to be stable) is 
% going in the background, when you can do stuff in the command line at
% the same time. HOWEVER, the vna sweep is not and the command line 
% won't react during the vna sweep.
%
% In development (May 13, 2017)
% 
% TODO: 
%   Done. add input parser
%   Done. choose vna sweep mode. Change 'plotTrace' to 'fetchTrace'
%   Done. choose temperature wait mode ('Near' or 'Stable')
%   Done. fetch actual temperatures and add timeStamps;
% 
% Wentao, May 2017
%

p = inputParser;
p.addParameter('vnaMode','plotTrace',@ischar);      % fetchTrace will directly fetch vna trace.
                                                    % Else, the E5071C/manualSweep method is called
p.addParameter('checkTempPeriod',10,@isnumeric);
p.addParameter('tempWaitMode','Stable',@ischar);    % another option is 'Near'
p.addParameter('manualSweepConfig',struct([]),@isstruct);   % parameters for the E5071C/manualSweep method as a structure

p.parse(varargin{:});
expandStructure(p.Results);

if strcmpi(vnaMode, 'plotTrace')
    freqs = vna.freqs;
    waitTime = vna.sweepTime;
else
    [freqs,waitTime] = vna.manualSweepFreqs(manualSweepConfig);
end
tempStableTmr = timer;
setTempTmr = timer;
set(tempStableTmr,'ExecutionMode','fixedRate');
set(tempStableTmr,'period',checkTempPeriod);    % check temperature stable period
set(tempStableTmr,'TimerFcn',@timerCalled);
set(tempStableTmr,'userdata',struct('ppms',ppms,'numOfTemps',length(temps),...
                            'manualSweepConfig',manualSweepConfig,...
                            'tempWaitMode',tempWaitMode,...
                            'vnaMode',vnaMode,...
                            'freqs',freqs,...
                            'timeStamps',NaN(1,length(temps)),...
                            'actualTemps',NaN(1,length(temps)),...
                            'vna',vna,'t',setTempTmr,'waitTime',waitTime,...
                            'cnt',1,'SParams',NaN(length(temps),length(freqs)) ) );

set(setTempTmr,'userdata',struct('ppms',ppms,'t',tempStableTmr,'temps',temps,'cnt',1) );
set(setTempTmr,'TimerFcn',@setTempTimerCalled);

start(setTempTmr);
end

%%
function timerCalled(thisObj,event)
ud = thisObj.UserData;
expandStructure(ud);
stat = char(ToString(ppms.tempStatus));
if strcmpi(stat, tempWaitMode)
    fprintf('Temperature %s, start vna averaging (%.2fs)...\n',...
            tempWaitMode,waitTime+0.5)
    
    % vna sweep
    if strcmpi(vnaMode, 'plotTrace')
        vna.clearAvg;
        pause(waitTime+0.5);
        trace = vna.trace;
    else
        [~,trace] = vna.manualSweep(manualSweepConfig);
    end
    fprintf('vna trace fetched.\n');
    
    % save SParams back into timer
    ud.actualTemps(cnt) = ppms.temp;
    ud.timeStamps(cnt) = now;
    ud.SParams(cnt,:) = trace.X(:)' + 1i*trace.Y(:)';
    ud.cnt = cnt + 1;
    thisObj.UserData = ud;
    stop(thisObj);
    fprintf('Temperature timer stopped at %s.\n', datestr(now,30))
    if ud.cnt <= numOfTemps
        fprintf('\n');
        start(t);
    else
        fprintf('Temperature sweep finished at %s\n',datestr(now,30));
        % save data
        expandStructure(ud);
        ud2 = t.UserData;
        setTemps = ud2.temps;
        actualTemps = ud.actualTemps;
        timeStamps = ud.timeStamps;
        startF = min(ud.freqs);
        stopF = max(ud.freqs);
        pow = vna.power;
        config = vna.getConfig;
        minT = min(setTemps);
        maxT = max(setTemps);
        fname = sprintf('TempSweep_start_%.4fGHz_stop_%.4fGHz_pow_%.1fdBm_minT_%.3fK_maxT_%.3fK_numT_%d_%s.mat',...
            startF/1e9,stopF/1e9,pow,minT,maxT,length(setTemps),datestr(now,30));
        save(fname,'SParams','waitTime','setTemps','actualTemps',...
            'freqs','config','timeStamps','manualSweepConfig');
        fprintf('%s saved.\n',fname);
    end
else
    fprintf('Temperature is %s. Waiting for temperature to be %s...\n',...
        stat,tempWaitMode)
end

end

%%
function setTempTimerCalled(thisObj,event)
ud = thisObj.UserData;
expandStructure(ud);
temp = temps(cnt);
fprintf('Set ppms temperature to %.4f K, %s\n',temp,datestr(now,30));
ppms.setTemp(temp,'tempApproach','NoOvershoot','tempRate',1);
pause(0.5);
start(t);
ud.cnt = cnt+1;
thisObj.UserData = ud;

end
\end{lstlisting}
  % subsection 扫描温度 (end)

  \subsection{扫描磁场} % (fold)
  \label{sub:扫描磁场}
  \begin{lstlisting}
%%
function [fldStableTmr, setFldTmr] = FieldSweep(ppms,vna,BFields,varargin)
% field sweep
%
% Parameters:
%   ppms: the PPMS object
%   vna: the E5071C object
%   BFields: Magnetic fields to sweep, in ***GAUSS***!!! (1 gauss = 0.1 mT)
%   varargin: optional input arguments, see inputParser below for detail
%
% Returns:
%   Two timer object tempStableTmr and setTempTmr.
% 
%   Sweep results will be automatically saved.
%   You can also find parameters and sweep results in
%   fldStableTmr.UserData and setFldTmr.UserData
%   It's better to delete and clear the timer object since they'll remained
%   in the memory:
%         delete(fldStableTmr);
%         delete(setFldTmr);
%         clear fldStableTmr;
%         clear setFldTmr;
%
% ATTENTION: the waiting process (for the field to be stable) is 
% going in the background, when you can do stuff in the command line at
% the same time. HOWEVER, the vna sweep is not and the command line 
% won't react during the vna sweep.
%
% In development (May 16, 2017)
% 
% Wentao, May 2017
%

p = inputParser;
p.addParameter('vnaMode','plotTrace',@ischar);      % fetchTrace will directly fetch vna trace.
                                                    % Else, the E5071C/manualSweep method is called
p.addParameter('checkFldPeriod',5,@isnumeric);
p.addParameter('fldWaitMode','StableDriven',@ischar);    % another option is 'Near'
p.addParameter('manualSweepConfig',struct([]),@isstruct);   % parameters for the E5071C/manualSweep method as a structure

p.parse(varargin{:});
expandStructure(p.Results);

if strcmpi(vnaMode, 'plotTrace')
    freqs = vna.freqs;
    waitTime = vna.sweepTime;
else
    [freqs,waitTime] = vna.manualSweepFreqs(manualSweepConfig);
end
fldStableTmr = timer;
setFldTmr = timer;
set(fldStableTmr,'ExecutionMode','fixedRate');
set(fldStableTmr,'period',checkFldPeriod);    % check field stable period
set(fldStableTmr,'TimerFcn',@timerCalled);
set(fldStableTmr,'userdata',struct('ppms',ppms,'numOfFlds',length(BFields),...
                            'manualSweepConfig',manualSweepConfig,...
                            'fldWaitMode',fldWaitMode,...
                            'vnaMode',vnaMode,...
                            'freqs',freqs,...
                            'timeStamps',NaN(1,length(BFields)),...
                            'actualFields',NaN(1,length(BFields)),...
                            'vna',vna,'t',setFldTmr,'waitTime',waitTime,...
                            'cnt',1,'SParams',NaN(length(BFields),length(freqs)) ) );

set(setFldTmr,'userdata',struct('ppms',ppms,'t',fldStableTmr,...
                                'BFields',BFields,'cnt',1) );
set(setFldTmr,'TimerFcn',@setFldTimerCalled);

start(setFldTmr);
end

%%
function timerCalled(thisObj,event)
ud = thisObj.UserData;
expandStructure(ud);
stat = char(ToString(ppms.fieldStatus));
if strcmpi(stat, fldWaitMode)
    fprintf('Field %s, start vna averaging (%.2fs)...\n',...
            fldWaitMode,waitTime+0.1)
    
    % vna sweep
    if strcmpi(vnaMode, 'plotTrace')
        vna.clearAvg;
        pause(waitTime+0.1);
        trace = vna.trace;
    else
        [~,trace] = vna.manualSweep(manualSweepConfig);
    end
    fprintf('vna trace fetched.\n');
    
    % save SParams back into timer
    ud.actualFields(cnt) = ppms.field;
    ud.timeStamps(cnt) = now;
    ud.SParams(cnt,:) = trace.X(:)' + 1i*trace.Y(:)';
    ud.cnt = cnt + 1;
    thisObj.UserData = ud;
    stop(thisObj);
    fprintf('Field timer stopped at %s.\n', datestr(now,30))
    if ud.cnt <= numOfFlds
        fprintf('\n');
        start(t);
    else
        fprintf('Field sweep finished at %s\n',datestr(now,30));
        % save data
        expandStructure(ud);
        ud2 = t.UserData;
        setFields = ud2.BFields;
        actualFields = ud.actualFields;
        timeStamps = ud.timeStamps;
        startF = min(ud.freqs);
        stopF = max(ud.freqs);
        pow = vna.power;
        config = vna.getConfig;
        minB = min(setFields);
        maxB = max(setFields);
        fname = sprintf('FieldSweep_start_%.4fGHz_stop_%.4fGHz_pow_%.1fdBm_minB_%.0fG_maxB_%.0fG_numB_%d_%s.mat',...
            startF/1e9,stopF/1e9,pow,minB,maxB,length(setFields),datestr(now,30));
        save(fname,'SParams','waitTime','setFields','actualFields',...
            'freqs','config','timeStamps','manualSweepConfig');
        fprintf('%s saved.\n',fname);
    end
else
    fprintf('Field is %s, Waiting for field to be %s...\n',...
        stat,fldWaitMode)
end

end

%%
function setFldTimerCalled(thisObj,event)
ud = thisObj.UserData;
expandStructure(ud);
fld = BFields(cnt);
fprintf('Set ppms field to %.4f Gauss, %s\n',fld,datestr(now,30));
ppms.setField(fld,'fieldApproach','Linear','fieldRate',50);
ud.cnt = cnt+1;
thisObj.UserData = ud;
pause(0.5);
start(t);
end
  \end{lstlisting}
  % subsection 扫描磁场 (end)
  
  % section 扫描温度与磁场实验的代码 (end)

% chapter measurement_code (end)


\chapter{外文资料调研阅读报告}

% \title{英文资料的中文标题}

% {\heiti 摘要：} 本章为外文资料翻译内容。如果有摘要可以直接写上来，这部分好像没有
% 明确的规定。


% \chapter{其它附录}
% 前面两个附录主要是给本科生做例子。其它附录的内容可以放到这里，当然如果你愿意，可
% 以把这部分也放到独立的文件中，然后将其 \cs{input} 到主文件中。
